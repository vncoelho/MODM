// ===================================
// Main.cpp file generated by OptFrame
// Project MODM
// ===================================

#include <stdlib.h>
#include <math.h>
#include <iostream>

#include "../OptFrame/Loader.hpp"
#include "MODM/Evaluator.cpp"
#include "../OptFrame/Heuristics/VNS/MOVNSLevels.hpp"
#include "../OptFrame/Heuristics/VNS/MOVNSLevelsLocalSearch.hpp"
#include "../OptFrame/Heuristics/2PPLS.hpp"
#include "../OptFrame/Heuristics/MOLocalSearches/GPLS.hpp"
#include "../OptFrame/MultiEvaluator.hpp"
#include "../OptFrame/MultiObjSearch.hpp"
#include "../OptFrame/InitialPareto.h"
#include "../OptFrame/Heuristics/EvolutionaryAlgorithms/ES.hpp"
#include "../OptFrame/Heuristics/MOLocalSearches/MOBestImprovement.hpp"
#include "../OptFrame/Heuristics/MOLocalSearches/MORandomImprovement.hpp"
#include "../OptFrame/Util/CheckCommand.hpp"
#include <string>
#include "MODM.h"

using namespace std;
using namespace optframe;
using namespace MODM;

double findMaxProfit(vector<vector<double> > vParetoEval)
{
	double maxProfit = -10000000;
	for (int i = 0; i < vParetoEval.size(); i++)
		if (vParetoEval[i][0] > maxProfit)
			maxProfit = vParetoEval[i][0];
	return maxProfit;
}

double readUpperBound(string fileToFind)
{
	string filename = "./MODM/Instances/solution_EJOR.txt";
	double upperBound = -1;

	File* file;

	try
	{
		file = new File(filename);
	} catch (FileNotFound& f)
	{
		cout << "File '" << filename << "' not found" << endl;
		return false;
	}

	Scanner scanner(file);
	while (scanner.hasNext())
	{
		string checkName = scanner.nextLine();
		size_t findPos = checkName.find("&");

		string sub = checkName.substr(findPos + 1);
		string singleName = checkName.substr(0, findPos);
		double upperBoundValue = stod(sub);
//		cout << singleName<<" : "<<upperBoundValue << endl;

		char* chr = strdup(fileToFind.c_str());
		if (singleName == fileToFind)
			return upperBoundValue;
	}

	return upperBound;
}

int MOTOPDMC(int argc, char **argv)
{
	cout << "Welcome to the Bi-Objective TOPDMC!" << endl;
	// EXEC EXAMPLE:
	// .instance ./saidaMOTOPDMC ./saidaGeralMOTOPDMC 120 10 10 5 1

	int nOfArguments = 10;
	if (argc != (1 + nOfArguments))
	{
		cout << "Parametros incorretos!" << endl;
		cout << "Os parametros esperados sao: \n"
				"1 - instancia \n"
				"2 - saida - for saving solutions for each execution - type write\n"
				"3 - saida geral -- general file for savings all results - type append \n"
				"4 - timeMO\n"
				"5 - alphaBuilderInt\n"
				"6 - alphaNSInt \n"
				"7 - popSizeMOVNS \n"
				"8 - batch \n";
		"9 - purefilename for upperBound \n \n";
		exit(1);
	}

	RandGenMersenneTwister rg;
	long seed = time(NULL);

	seed = 10;

	srand(seed);
	rg.setSeed(seed);

	const char* instancia = argv[1];
	const char* saida = argv[2];
	const char* saidaGeral = argv[3];
	int time2PPLS = atoi(argv[4]);
	double maxAlphaBuilder = atof(argv[5]);
	double alphaNeighARProduct = atof(argv[6]);
	int initial_population_size = atoi(argv[7]);
	int argvNBatch = atoi(argv[8]);
	const char* argvInstPureName = argv[9];
	int argvNSNTries = atoi(argv[10]);

	string filepath = instancia;
	string output = saida;
	string outputGeral = saidaGeral;
	string instPureName = argvInstPureName;

//	instPureName = "S3-15/S3-10-15-1-s";
	//Find pure instance name
	size_t pureNamePos = instPureName.find("/");
	instPureName = instPureName.substr(pureNamePos + 1);

	double upperBound = readUpperBound(instPureName);

//	filepath = "./MODM/Instances/S3-15/S3-10-15-1-s.txt";
//	filepath = "./MODM/Instances/S3-5/S3-5-5-1-s.txt";
//	filepath = "./MODM/Instances/L-15/L-10-15-1-l.txt";
//	initial_population_size = 1000;
	alphaNeighARProduct = 0.1;	//0.001;
	maxAlphaBuilder = 0.8;
//	time2PPLS = 60;
//	alphaBuilder = 1;
//	initial_population_size = 5;
//	alphaNeighARProduct =0.05;
	argvNSNTries = 1;

	cout << "filepath = " << filepath << endl;
	cout << "instPureName = " << instPureName << endl;
	cout << "upperBound = " << upperBound << endl;
	cout << "output = " << output << endl;
	cout << "outputGeral = " << outputGeral << endl;
	cout << "time2PPLS = " << time2PPLS << endl;
	cout << "maxAlphaBuilder = " << maxAlphaBuilder << endl;
	cout << "alphaNeighARProduct = " << alphaNeighARProduct << endl;
	cout << "initial population size = " << initial_population_size << endl;
	cout << "argvNSNTries = " << argvNSNTries << endl;

//	getchar();

	cout << "Seed = " << seed << endl;

	File* file;

	try
	{
		file = new File(filepath);
	} catch (FileNotFound& f)
	{
		cout << "File '" << filepath << "' not found" << endl;
		return false;
	}

	Scanner scanner(file);

	ProblemInstance p(scanner, rg);

	MODMADSManager adsMan(p);
	MODMEvaluator eval(p, adsMan);
	MODMRobustnessEvaluator evalRobustness(p, adsMan, rg);

	ConstructiveBasicGreedyRandomized grC(p, rg, adsMan);
	//	grC.setMessageLevel(4);

	NSSeqSWAP nsseq_swap(rg, &p);
	NSSeqSWAPInter nsseq_swapInter(rg, &p);
	NSSeqInvert nsseq_invert(rg, &p);
	NSSeqARProduct nsseq_arProduct(rg, &p, alphaNeighARProduct, argvNSNTries);
	NSSeqADD nsseq_add(rg, &p);

	vector<Evaluator<RepMODM, AdsMODM>*> v_e;
	v_e.push_back(&eval);
	v_e.push_back(&evalRobustness);

	vector<NSSeq<RepMODM, AdsMODM>*> neighboors;
//	neighboors.push_back(&nsseq_swapInter);
	//neighboors.push_back(&nsseq_swap);

	neighboors.push_back(&nsseq_arProduct);
	neighboors.push_back(&nsseq_add);
	neighboors.push_back(&nsseq_swap);

//	neighboors.push_back(&nsseq_swapInter);

	MultiEvaluator<RepMODM, AdsMODM> mev(v_e);
	GRInitialPopulation<RepMODM, AdsMODM> bip(grC, rg, maxAlphaBuilder);
	GRInitialPareto<RepMODM, AdsMODM> grIP(grC, rg, maxAlphaBuilder, mev);

	MOVNSLevels<RepMODM, AdsMODM> multiobjectvns(v_e, bip, initial_population_size, neighboors, rg, 10, 10);

//	MOVNSLevelsLocalSearch<RepMODM, AdsMODM> multiobjectvns2(v_e, bip, initial_population_size, neighboors, rg, 10, 10);
	TwoPhaseParetoLocalSearch<RepMODM, AdsMODM> paretoSearch(mev, bip, initial_population_size, neighboors);

//	paretoManager<RepMODM, AdsMODM> addSolClass(mev);
	MOBestImprovement<RepMODM, AdsMODM> mobiGNS(mev, nsseq_arProduct);
	MOBestImprovement<RepMODM, AdsMODM> mobiADD(mev, nsseq_add);
	MORandomImprovement<RepMODM, AdsMODM> moriSwap(mev, nsseq_swap, 1000);
	MORandomImprovement<RepMODM, AdsMODM> moriSwapInter(mev, nsseq_swapInter, 1000);
	vector<MOLocalSearch<RepMODM, AdsMODM>*> vMOLS;
	bool NSOrder = true; // AR add or SWAPS
	if (NSOrder)
	{
		vMOLS.push_back(&mobiGNS);
		vMOLS.push_back(&mobiADD);
		vMOLS.push_back(&moriSwapInter);
		vMOLS.push_back(&moriSwap);
	}
	else
	{
		vMOLS.push_back(&moriSwapInter);
		vMOLS.push_back(&moriSwap);
		vMOLS.push_back(&mobiGNS);
		vMOLS.push_back(&mobiADD);
	}

	GeneralParetoLocalSearch<RepMODM, AdsMODM> generalPLS(mev, grIP, initial_population_size, vMOLS);

	// Check Module
	/*	CheckCommand<RepMODM, AdsMODM> cm(true);
	 cm.add(adsMan);
	 cm.add(grC);
	 cm.add(eval);
	 cm.add(nsseq_swap);
	 cm.add(nsseq_arProduct);
	 cm.add(nsseq_swapInter);
	 cm.run(5, 1);
	 getchar();*/

	Pareto<RepMODM, AdsMODM> pf;
	Pareto<RepMODM, AdsMODM> pfInitialPareto;

	double searchTimeLimit = 1;
	searchTimeLimit = time2PPLS;
	for (int exec = 0; exec < 1; exec++)
	{
		Timer tnow;
//		multiobjectvns.search(2, 0);
		pfInitialPareto = grIP.generatePareto(initial_population_size, searchTimeLimit);
		cout << "Main Printing: \n Initial Pareto with: " << initial_population_size << " solutions has found: " << pfInitialPareto.size() << " non-DS with: " << tnow.now() << " seconds! \n" << endl;

		if (searchTimeLimit - tnow.now() > 0)
		{
			pf = *generalPLS.search(searchTimeLimit - tnow.now());
		}
		else
			pf = pfInitialPareto;
//		pf = *paretoSearch.search(60, 0, &pf);
	}

//	pf->clear();

	cout << "MO optimization finished! Printing Pareto Front!" << endl;

	MOMETRICS<RepMODM, AdsMODM> US(v_e);
	vector<vector<double> > initialParetoEvaluations = US.getParetoEvaluations(pfInitialPareto, v_e.size());
	vector<vector<double> > finalPareto = US.getParetoEvaluations(pf, v_e.size());
	vector<vector<double> > PFCheck;

	vector<Solution<RepMODM, AdsMODM>*> vSolPf = pf.getParetoSet();
	int nObtainedParetoSol = vSolPf.size();
	for (int i = 0; i < nObtainedParetoSol; i++)
	{
		Solution<RepMODM, AdsMODM>* sol = vSolPf[i];
		const RepMODM& rep = sol->getR();
		const AdsMODM& ads = sol->getADS();
		vector<double> solEvaluations;
		double foProfit = finalPareto[i][0];
		double foVolatility = finalPareto[i][1];
		solEvaluations.push_back(foProfit);
		solEvaluations.push_back(foVolatility);
		US.addSol(PFCheck, solEvaluations);

		vector<int> nPerCat = evalRobustness.checkNClientsPerCategory(rep, ads);
		cout << foProfit << "\t" << foVolatility << "\t";

		int nTotalClients = nPerCat[nPerCat.size() - 1];

		for (int cat = 0; cat < 6; cat++)
			cout << nPerCat[cat] << "\t";
		cout << endl;
	}

	bool errorOnParetoDominance = false;
	if (finalPareto.size() != PFCheck.size())
	{
		errorOnParetoDominance = true;
		cout << "ERROR ! PFCheck and finalPareto has different size! Some problem might had happen during the optimization..." << endl;
		for (int p = 0; p < PFCheck.size(); p++)
		{
			cout << PFCheck[p][0] << "\t" << PFCheck[p][1] << endl;
		}
	}
//	cout<<"ReadingPareto..."<<endl;
//	vector<vector<double> > PF1 = US.readPF("./MyProjects/paretoCorsTesteS3-1", 291, nOF);
//	vector<vector<double> > PF2 = US.readPF("./MyProjects/paretoCorsTesteS3-2", 262, nOF);
//	vector<vector<double> > ref = US.unionSets(PF1, PF2);
//	vector<vector<double> > refMin = ref;
//
//	cout << PF1.size() << endl;
//	cout << PF2.size() << endl;
//	cout << ref.size() << endl;
//	//	getchar();
//	cout << "Reference set" << endl;
//	for (int p = 0; p < ref.size(); p++)
//	{
////		cout << ref[p][0] << "\t" << ref[p][1] << endl;
//		refMin[p][0] *= -1;
//		refMin[p][1] *= -1;
//	}

	//Delta Metric and Hipervolume are working requires Minimization problems
	vector<double> utopicSol;
	utopicSol.push_back(-upperBound);
	utopicSol.push_back(-1000);
	vector<double> objReferences;
	objReferences.push_back(0);
	objReferences.push_back(0);

//	int card = US.cardinalite(paretoDoubleEval, ref);
//	double sCToRef = US.setCoverage(paretoDoubleEval, ref);
//	double sCFromRef = US.setCoverage(ref, paretoDoubleEval);

	double maxProfit = findMaxProfit(finalPareto);
	double hv = US.hipervolumeWithExecRequested(finalPareto, objReferences, false);
	double delta = US.deltaMetric(finalPareto, utopicSol, false);
	double hvInitial = US.hipervolumeWithExecRequested(initialParetoEvaluations, objReferences, false);
	double deltaInitial = US.deltaMetric(initialParetoEvaluations, utopicSol, false);
	int cardInitial = US.cardinalite(initialParetoEvaluations, finalPareto);

//	cout << "Cardinalite = " << card << endl;
//	cout << "Set Coverage to ref = " << sCToRef << endl;
//	cout << "Set Coverage from ref  = " << sCFromRef << endl;
//	cout << "deltaRef  = " << US.deltaMetric(refMin, utopicSol) << endl;
//	cout << "ref  = " << US.hipervolumeWithExecRequested(refMin, objReferences) << endl;

	cout << "maxProfit  = " << maxProfit << endl;
	cout << "delta  = " << delta << endl;
	cout << "hv  = " << hv << endl;
	cout << "deltaInitial  = " << deltaInitial << endl;
	cout << "hvInitial  = " << hvInitial << endl;
	cout << "cardInitial  = " << cardInitial << endl;
	cout << "errorOnParetoDominance  = " << errorOnParetoDominance << endl;

	FILE* fGeral = fopen(outputGeral.c_str(), "a");

	size_t pos = filepath.find("Instances/");
	string instName = filepath.substr(pos);

	int NSANPP = false;

	fprintf(fGeral, "%s \t %d \t %.7f \t %.7f \t %d \t %d \t %d \t %ld \t", instName.c_str(), initial_population_size, maxAlphaBuilder, alphaNeighARProduct, NSOrder, NSANPP, argvNSNTries, seed);
	fprintf(fGeral, "%d \t %.7f \t %.7f \t %.7f \t %.7f \t %d \t %.7f \t %d \n", nObtainedParetoSol, hv, delta, hvInitial, deltaInitial, cardInitial, maxProfit, errorOnParetoDominance);

//	fprintf(fGeral, "%s \t %d \t %.7f \t %.7f \t %d \t %.7f \t %.7f \t %.7f \t %.7f \t %.7f \t %d \t %d  \t %ld \n", instName.c_str(), initial_population_size, maxAlphaBuilder, alphaNeighARProduct, nObtainedParetoSol, hv, delta, hvInitial, deltaInitial, cardInitial, maxProfit, NSChangeAddOrder, argvNSNTries, seed);
//	fprintf(fGeral, "%s \t %d \t %.7f \t %.7f \t %d \t %d \t %.7f \t %.7f \t %.7f \t %.7f \t %ld \n", instName.c_str(), initial_population_size, alphaBuilder, alphaNeighARProduct, nObtainedParetoSol, card, sCToRef, sCFromRef, hv, delta, seed);

	fclose(fGeral);

	cout << "Bi-Objective TOPDMC ended with success!" << endl;
	return 0;
}

