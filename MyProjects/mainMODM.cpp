// ===================================
// Main.cpp file generated by OptFrame
// Project MODM
// ===================================

#include <stdlib.h>
#include <math.h>
#include <iostream>

#include "mainMOMODM.hpp"
#include "../OptFrame/Loader.hpp"
#include "MODM/Evaluator.cpp"
#include "../OptFrame/Heuristics/VNS/MOVNSLevels.hpp"
#include "../OptFrame/Heuristics/2PPLS.hpp"
#include "../OptFrame/MultiEvaluator.hpp"
#include "../OptFrame/MultiObjSearch.hpp"
#include "../OptFrame/Heuristics/EvolutionaryAlgorithms/ES.hpp"
#include <string>
#include "MODM.h"

using namespace std;
using namespace optframe;
using namespace MODM;

int main(int argc, char **argv)
{
	// BOOKS EXEC EXAMPLE:
	// ./MyProjects/MODM/Instances/M1-10/M1-10-10-1-l ./teste ./testeES 120 10 10 5 10
	int multiObjectiveOPTOn = true;
	if (multiObjectiveOPTOn)
	{
		MOTOPDMC(argc, argv);
		return(0);
	}

	int nOfArguments = 11;
	if (argc != (1 + nOfArguments))
	{
		cout << "Parametros incorretos!" << endl;
		cout << "Os parametros esperados sao: \n"
				"1 - instancia \n"
				"2 - saida - for saving solutions for each execution - type write\n"
				"3 - saida geral -- general file for savings all results - type append \n"
				"4 - timeILS\n"
				"5 - alphaBuilderInt\n"
				"6 - alphaNSInt \n"
				"7 - initialSol \n"
				"8 - mu \n"
				"9 - pp \n"
				"10 - nBooks \n"
				"11 - batch \n \n";
		exit(1);
	}

	RandGenMersenneTwister rg;
	long seed = time(NULL);

//	seed = 30;

	srand(seed);
	rg.setSeed(seed);

	const char* instancia = argv[1];
	const char* saida = argv[2];
	const char* saidaGeral = argv[3];
	int argvTimeILS = atoi(argv[4]);
	int alphaBuilderInt = atoi(argv[5]);
	int alphaNSInt = atoi(argv[6]);
	int pop = atoi(argv[7]);
	int argvMU = atoi(argv[8]);
	int argvPP = atoi(argv[9]);
	int argvNBooks = atoi(argv[10]);
	int argvNBatch = atoi(argv[11]);

	double alphaBuilder = alphaBuilderInt / 10.0;
	double alphaNeighARProduct = alphaNSInt / 10.0;

	string filename = instancia;
	string output = saida;
	string outputGeral = saidaGeral;
	cout << "filename = " << filename << endl;
	cout << "output = " << output << endl;
	cout << "outputGeral = " << outputGeral << endl;
	cout << "argvTimeILS = " << argvTimeILS << endl;
	cout << "alphaBuilder = " << alphaBuilder << endl;
	cout << "alphaNeighARProduct = " << alphaNeighARProduct << endl;
	cout << "initial population size = " << pop << endl;
	cout << "Seed = " << seed << endl;

	filename = filename + ".txt";

	//filename = "./MyProjects/MODM/Instances/S3-15/S3-10-15-1-s.txt";
//	filename = "./MyProjects/MODM/Instances/L-10/L-10-10-1-l.txt";

//filename = "./MyProjects/MODM/Instances/BooksCampaign/B200-C100-pp1-1";
//filename = "./MyProjects/MODM/Instances/L-5/L-15-5-2-s.txt";
//filename = "testInstanceBookOfferCampaing.txt";

//for the booksOffer
	double profitRate = 1.1 + (argvPP / 10.0);
	stringstream ssInstanceName;
	ssInstanceName << "./MyProjects/MODM/Instances/BooksCampaign/batch" << argvNBatch << "/" << "B" << argvNBooks << "-C" << 100 << "-pp" << profitRate << "-" << argvNBatch;
	filename = ssInstanceName.str();
	cout << "reading instance " << ssInstanceName.str() << endl;

	File* file;

	try
	{
		file = new File(filename);
	} catch (FileNotFound& f)
	{
		cout << "File '" << filename << "' not found" << endl;
		return false;
	}

	Scanner scanner(file);

	ProblemInstance p(scanner, rg);

//	vector<int> nClientsInstance;
//	nClientsInstance.push_back(100);
//	nClientsInstance.push_back(1000);

//	int nClients = 100;	//10;
//	int nBooks = 200;	//20;
//	double profitRate = 1 + (pp / 10.0);
//	double hurdleRate = 0.15; // 0.05 and 0.1
//	double maxPerClients = 3; // 0.05 and 0.1
//	int nMInstancePerConfiguration = 1;
//
//	for (int batch = 1; batch <= nMInstancePerConfiguration; batch++)
//	{
//		p.generateBicliqueProblem(100, 10, profitRate, hurdleRate, maxPerClients, batch);
//		p.generateBicliqueProblem(100, 20, profitRate, hurdleRate, maxPerClients, batch);
//		p.generateBicliqueProblem(100, 50, profitRate, hurdleRate, maxPerClients, batch);
//		p.generateBicliqueProblem(100, 100, profitRate, hurdleRate, maxPerClients, batch);
//		p.generateBicliqueProblem(100, 200, profitRate, hurdleRate, maxPerClients, batch);
//	}

//	p.generateExample();
//	getchar();

//	p.generateBicliqueProblem(nClients, nBooks, profitRate, hurdleRate, maxPerClients, 1);
//	cout << "instance generated with success!" << endl;
//	exit(1);

// add everything to the HeuristicFactory 'hf'

	MODMADSManager adsMan(p);
	MODMEvaluator eval(p, adsMan);
	MODMRobustnessEvaluator evalRobustness(p, adsMan, rg);

	ConstructiveBasicGreedyRandomized grC(p, rg, adsMan);
//	grC.setMessageLevel(4);

	NSSeqSWAP nsseq_swap(rg, &p);
	NSSeqSWAPInter nsseq_swapInter(rg, &p);
	NSSeqInvert nsseq_invert(rg, &p);
	NSSeqARProduct nsseq_arProduct(rg, &p, alphaNeighARProduct,1);
	NSSeqADD nsseq_add(rg, &p);

// ================ BEGIN OF CHECK MODULE ================

	/*	CheckCommand<RepMODM, AdsMODM> check(false);
	 check.add(grC);
	 check.add(eval);
	 //check.add(nsseq_swap);
	 //check.add(nsseq_swapInter);
	 check.add(nsseq_invert);
	 //check.add(nsseq_arProduct);

	 check.run(1, 1);
	 getchar();*/

// ================ END OF CHECK MODULE ================
	FirstImprovement<RepMODM, AdsMODM> fiSwap(eval, nsseq_swap);
	FirstImprovement<RepMODM, AdsMODM> fiSwapInter(eval, nsseq_swapInter);
	FirstImprovement<RepMODM, AdsMODM> fiInvert(eval, nsseq_invert);
	FirstImprovement<RepMODM, AdsMODM> fiAR(eval, nsseq_arProduct);

	int nMovesRDM = 50000;
	RandomDescentMethod<RepMODM, AdsMODM> rdmSwap(eval, nsseq_swap, nMovesRDM);
	RandomDescentMethod<RepMODM, AdsMODM> rdmSwapInter(eval, nsseq_swapInter, nMovesRDM);
	RandomDescentMethod<RepMODM, AdsMODM> rdmInvert(eval, nsseq_invert, nMovesRDM);
	RandomDescentMethod<RepMODM, AdsMODM> rdmARProduct(eval, nsseq_arProduct, 100);
	RandomDescentMethod<RepMODM, AdsMODM> rdmADD(eval, nsseq_add, 1);

	vector<LocalSearch<RepMODM, AdsMODM>*> vLS;
//vLS.push_back(&fiSwap);
// vLS.push_back(&fiSwapInter);
//vLS.push_back(&fiInvert);

	vLS.push_back(&rdmSwapInter);
	vLS.push_back(&rdmSwap);
//vLS.push_back(&fiAR);
//vLS.push_back(&rdmARProduct);
	vLS.push_back(&rdmADD);
//vLS.push_back(&rdmInvert);

	VariableNeighborhoodDescent<RepMODM, AdsMODM> vnd(eval, vLS);

//ILSLPerturbationLPlus2<RepMODM, AdsMODM> ilsl_pert(eval, 100000, nsseq_invert, rg);
	ILSLPerturbationLPlus2<RepMODM, AdsMODM> ilsl_pert(eval, 100000, nsseq_arProduct, rg);
//ILSLPerturbationLPlus2<RepMODM, AdsMODM> ilsl_pert(eval, 100000, nsseq_add, rg);
	ilsl_pert.add_ns(nsseq_add);
	ilsl_pert.add_ns(nsseq_swapInter);
	ilsl_pert.add_ns(nsseq_swap);
	ilsl_pert.add_ns(nsseq_invert);

	IteratedLocalSearchLevels<RepMODM, AdsMODM> ils(eval, grC, vnd, ilsl_pert, 50, 15);
	ils.setMessageLevel(3);

	pair<Solution<RepMODM, AdsMODM>&, Evaluation&>* finalSol;

	EmptyLocalSearch<RepMODM, AdsMODM> emptyLS;
	BasicGRASP<RepMODM, AdsMODM> g(eval, grC, emptyLS, alphaBuilder, 100000);

	g.setMessageLevel(3);
	int timeGRASP = 100;
	double target = 9999999;


//======================= EVolution Strategies for the MIT PAPER ==============
	NSSeqSWAP* nsseq_swapPonteiro = new NSSeqSWAP(rg, &p);
	NSSeqSWAPInter* nsseq_swapInterPonteiro = new NSSeqSWAPInter(rg, &p);
	NSSeqInvert* nsseq_invertPonteiro = new NSSeqInvert(rg, &p);
	NSSeqARProduct* nsseq_arProductPonteiro = new NSSeqARProduct(rg, &p, alphaNeighARProduct, 1);
	NSSeqADD* nsseq_addPonteiro = new NSSeqADD(rg, &p);
	vector<NSSeq<RepMODM, AdsMODM>*> vNSeq;

	vNSeq.push_back(nsseq_swapInterPonteiro);
	vNSeq.push_back(nsseq_swapPonteiro);
	vNSeq.push_back(nsseq_invertPonteiro);
	vNSeq.push_back(nsseq_arProductPonteiro);
	vNSeq.push_back(nsseq_addPonteiro);

	vector<int> vNSeqMax(vNSeq.size(), 10);
	vNSeqMax[vNSeqMax.size() - 1] = 1; // onlyIf Add is on, because its is a single move.

	double mutationRate = 0.1;
	int selectionType = 1;
	string outputFile = "./ESResults/LogMIT-ES-10-COMPLETE-VND-RDM-5000-LongRun2-L5";
	int mu = argvMU;
	mu = 10;
	int lambda = mu * 6;
	int esMaxG = 1000000;

//  mu = 20;
//  lambda = 60;

	ES<RepMODM, AdsMODM> es(eval, grC, vNSeq, vNSeqMax, vnd, selectionType, mutationRate, rg, mu, lambda, esMaxG, outputFile, 0);
	es.setMessageLevel(3);

//MODMProblemCommand problemCommand(rg);

	finalSol = ils.search(argvTimeILS, target);
//	finalSol = es.search(1200, target);

	cout << finalSol->second.evaluation() << endl;
	cout << "ES FINISHED WITH SUCCESS!" << endl;
	double fo = finalSol->second.evaluation();
	int isFeasible = finalSol->second.isFeasible();
	FILE* fGeral = fopen(outputGeral.c_str(), "a");

	size_t pos = filename.find("Instances/");
	string instName = filename.substr(pos);

//print books
	fprintf(fGeral, "%f\t%d\t%d\t%f\t%d\t%d\t%ld\n", fo, isFeasible, argvNBooks, profitRate, argvNBatch, argvTimeILS, seed);

	//fprintf(fGeral, "%s\t%.7f\t%d \t %f\t%f\t%d\t%ld\n", instName.c_str(), fo, isFeasible, alphaBuilder, alphaNeighARProduct, mu, seed);

	fclose(fGeral);
	//======================= END MIT PAPER ==============


	//===========================================

	/*
	 //timeILS = 6;

	 finalSol = ils.search(timeILS, target);

	 cout << "ILS HAS ENDED!" << endl;
	 finalSol->second.print();
	 //finalSol->first.print();

	 RepMODM repFinal = finalSol->first.getR();
	 //finalSol = g.search(time,target);

	 //cout << eval.getAverageTime() << endl;
	 //cout << eval.getAverageTimeEvalComplete() << endl;

	 double fo = finalSol->second.evaluation();
	 int isFeasible = finalSol->second.isFeasible();

	 FILE* fResults = fopen(output.c_str(), "w");

	 fprintf(fResults, "%.7f \t %d \t%f\t%f\t %ld", fo, isFeasible, alphaBuilder, alphaNeighARProduct, seed);
	 fprintf(fResults, "\n Solution");
	 for (int c = 0; c < p.getNumberOfClients(); c++)
	 {
	 fprintf(fResults, "\n", fo, isFeasible);
	 for (int product = 0; product < p.getNumberOfProducts(); product++)
	 {
	 fprintf(fResults, "%d\t", repFinal[c][product]);
	 }
	 }

	 fprintf(fResults, "\n");

	 fclose(fResults);

	 FILE* fGeral = fopen(outputGeral.c_str(), "a");

	 size_t pos = filename.find("Instances/");
	 string instName = filename.substr(pos);

	 fprintf(fGeral, "%s\t%.7f\t%d \t %f\t%f\t%ld\n", instName.c_str(), fo, isFeasible, alphaBuilder, alphaNeighARProduct, seed);

	 fclose(fGeral);

	 */
	return 0;

}

